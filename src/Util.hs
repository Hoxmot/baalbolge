module Util
    ( -- * Data types
      Command (..)

      -- * Util functions
      , checkParentheses
      , showTree
      , readCommand

      -- * Not implemented handling
      , notImplemented
      , notImplementedError
  ) where

import           Baalbolge.Print (Print, printTree)
import           System.Exit     (exitFailure)


-- | A command for controlling the interpeter in the interactive mode.
data Command = Exit | Help | Parse
  deriving (Show)

{- | Takes a string and an integer and checkes the number of opening and closing
parentheses in the string. Returns the given integer increased by the number of opening
parentheses and decreased by the number of closing parentheses.
It doesn't check the correctness of the parentheses.

>>> checkParentheses "(" 0
1

>>> checkParentheses ")" 0
-1

>>> checkParentheses "()" 0
0

>>> checkParentheses "(())()()" 0
0

>>> checkParentheses ")(" 0
0
-}
checkParentheses :: String -> Int -> Int
checkParentheses ('(':t) c = checkParentheses t (c + 1)
checkParentheses (')':t) c = checkParentheses t (c - 1)
checkParentheses (_:t) c   = checkParentheses t c
checkParentheses [] c      = c

{- | Tries to match a string with one of the commands. If it can't, it assumes the command
is parsing.

>>> readCommand "\\q"
Exit

>>> readCommand "\\h"
Help

>>> readCommand "Lorem ipsum dolor sit amet duis."
Parse

>>> readCommand "a\\q"
Parse

>>> readCommand "b\\h"
Parse
-}
readCommand :: String -> Command
readCommand "\\q" = Exit
readCommand "\\h" = Help
readCommand _     = Parse

-- | Prints parsed syntax tree. Shamelessly stolen from parser generated by BNFC.
showTree :: (Show a, Print a) => a -> IO ()
showTree tree = do
    putStrLn $ "\n[Abstract Syntax]\n\n" ++ show tree
    putStrLn $ "\n[Linearized tree]\n\n" ++ printTree tree

notImplemented :: IO()
notImplemented = putStrLn "Not yet implemented..."

notImplementedError :: IO()
notImplementedError = notImplemented >> putStrLn "Quitting..." >> exitFailure
